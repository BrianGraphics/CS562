#version 460

layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

layout (rgba32f, binding = 2) uniform readonly  image2D src;
layout (rgba32f, binding = 3) uniform writeonly image2D dst;

float pi = 3.14159265359;

float GetBasis(int index, float theta, float phi);
float EvalSH(vec3 N, int index);

void main()
{        
    ivec2 dst_size = imageSize(dst);

    ivec2 gpos = ivec2(gl_GlobalInvocationID.xy);
    vec4 SHCoeff[9];
    for(int i = 0; i < 9; ++i) { SHCoeff[i] = vec4(0.0); SHCoeff[i] = imageLoad(src, ivec2(i, 0)); }
    

    if(gpos.x < 9 && gpos.y == 0) {
        imageStore(dst, gpos, SHCoeff[gpos.x]);
        return;
    }

    float w = float(dst_size.x);
    float h = float(dst_size.y);

    float curr_theta = pi * (float(gpos.y) + 0.5) / 100.0;
    float curr_phi   = 2.0 * pi * (float(gpos.x) + 0.5) / 200.0;
    vec3 curr_N = vec3(sin(curr_theta) * cos(curr_phi), sin(curr_theta) * sin(curr_phi), cos(curr_theta));

    vec4 irr;
    for(int index = 0; index < 9; ++index) {        
        irr += SHCoeff[index] * EvalSH(curr_N, index);
    }

    //irr = 0.5 * irr / (0.5 * irr + vec4(1.0));
    //irr = pow(irr, vec4(1.0/2.2));
    imageStore(dst, gpos, irr);   
    //imageStore(dst, gpos, irr);   
}

float EvalSH(vec3 N, int index) {
    float C0   = 0.88622692545f; // A0 * Y0
    float C1   = 1.02332670795f; // A1 * Y1
    float C2   = 0.85808553081f; // A2 * Y2_2, A2 * Y2_1, A2 * Y21
    float C20  = 0.2477079561f;  // A2 * Y20
    float C22  = 0.4290427654f;  // A2 * Y22                

    float x = N.x;
    float y = N.y;
    float z = N.z;    

    switch (index) {
        case 0:
            return C0;
        case 1:
            return -C1  * y;
        case 2:
            return C1  * z;
        case 3:
            return -C1  * x;
        case 4:
            return C2  * x * y;
        case 5:
            return -C2  * y * z;
        case 6:
            return C20  * (3.0 * z * z - 1.0);
        case 7:
            return -C2  * x * z;
        case 8:
            return C22  * (x * x - y * y);
    }

    // Should not get here. Index is wrong!
    return 0.0;
}