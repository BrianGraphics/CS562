#version 460

layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

float pi = 3.14159;

layout(binding = 3) uniform shCoeffs
{
    vec4 coeffs[9];
};

layout (rgba32f, binding = 4) uniform writeonly image2D irrImage;

double EvalSH(vec3 N, int index);

double C0   =        pi * 0.5  * sqrt(1.0  / pi); // A0 * Y0
double C1   = 0.67 * pi * 0.5  * sqrt(3.0  / pi); // A1 * Y1
double C2   = 0.25 * pi * 0.5  * sqrt(15.0 / pi); // A2 * Y2_2, A2 * Y2_1, A2 * Y21
double C20  = 0.25 * pi * 0.25 * sqrt(5.0  / pi); // A2 * Y20
double C22  = 0.25 * pi * 0.25 * sqrt(15.0 / pi); // A2 * Y22   


void main()
{        
    ivec2 size = ivec2(400, 200);
    
    float w = float(size.x);
    float h = float(size.y);

    ivec2 gpos = ivec2(gl_GlobalInvocationID.xy);
    float curr_theta = pi * (float(gpos.y) + 0.5) / h;
    float curr_phi   = 2.0 * pi * (float(gpos.x) + 0.5) / w;
    vec3 curr_N = vec3( sin(curr_theta) * cos(curr_phi), sin(curr_theta) * sin(curr_phi), cos(curr_theta));
    curr_N = normalize(curr_N);

    vec4 irr = vec4(0.0);
    for(int index = 0; index < 9; ++index) {        
        irr += coeffs[index] * float(EvalSH(curr_N, index));
    }
    
    irr = 1.0 * irr / (1.0 * irr + vec4(1.0));
    irr = pow(irr, vec4(3.0/2.2));
    imageStore(irrImage, gpos, irr);    
}

double EvalSH(vec3 N, int index) {    
    double x = N.x;
    double y = N.y;
    double z = N.z;    

    switch (index) {
        case 0:
            return C0;
        case 1:
            return C1  * y;
        case 2:
            return C1  * z;
        case 3:
            return C1  * x;
        case 4:
            return C2  * x * y;
        case 5:
            return C2  * y * z;
        case 6:
            return C20  * (3.0 * z * z - 1.0);
        case 7:
            return C2  * x * z;
        case 8:
            return C22  * (x * x - y * y);
    }

    // Should not get here. Index is wrong!
    return 0.0;
}